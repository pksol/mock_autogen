import ast
import functools
import logging
import re
import sys
import textwrap
import types
from collections import namedtuple, OrderedDict

from enum import Enum
import inspect

import mock as python_mock
import unittest.mock

from mock_autogen.utils import copy_result_to_clipboard, print_result, \
    get_unique_item

logger = logging.getLogger(__name__)

MockingFramework = Enum('MockingFramework', 'PYTEST_MOCK')
CallParameters = namedtuple('CallParameters', 'args, kwargs')


@copy_result_to_clipboard
@print_result
def generate_mocks(framework,
                   mocked,
                   name='',
                   mock_modules=True,
                   mock_functions=False,
                   mock_builtin=True,
                   mock_classes=False,
                   mock_referenced_classes=True,
                   mock_classes_static=False,
                   prepare_asserts_calls=True):
    """
    Generates the list of mocks in order to mock the dependant modules and the
    functions of a given module, class or object instance.

    Note that the returned code is the initial basic code on which you can add
    your custom logic like function return values.

    This method can also be used to prepare the calls to `generate_asserts`, in
    case `prepare_asserts_calls` is set to `True`.

    Args:
        framework (MockingFramework): the type of the mocking
            framework to use
        mocked (object): the object to mock, might be
            `types.ModuleType`, a class or just a plain object instance
        name (str): the name of the mocked object, to be put in the
            generated code. If the name is not provided, the following logic
            would be used to determine its name: for modules - the name of the
            module. For anything else, would be guessed to match the argument
            name sent to the method and finally defaulted to 'arg'
        mock_modules (bool): whether to mock dependant modules which are
            referenced from the mocked object. Relevant only if `mocked`
            is `types.ModuleType`
        mock_functions (bool): whether to mock functions / methods defined in
            the mocked object
        mock_builtin (bool): whether to mock builtin functions defined in the
            module. Relevant only if `mocked` is `types.ModuleType`
        mock_classes (bool): whether to mock classes defined in the module, or
            a sent class. Ignored if this is a plain instance
        mock_referenced_classes (bool): whether to mock classes referenced in
            the module but defined elsewhere. Relevant only if `mocked`
            is `types.ModuleType`
        mock_classes_static (bool): whether to mock the static functions of the
            mocked classes. This is important if the tested code uses
            static class functions directly. Used only if
            mock_classes or mock_referenced_classes is `True`.
            Ignored if this is a plain instance
        prepare_asserts_calls (bool): whether to generate the subsequent calls
            to `generate_asserts` for the mocks generated by this call

    Returns:
        str: the initial code to put in your test to mock the desired behaviour
    """
    modules = []
    functions = []
    classes = []
    methods = []

    # we're mocking a class
    if inspect.isclass(mocked):
        name = name if name else _guess_var_name(name)
        if mock_classes:
            classes.append(mocked.__name__)
        if mock_functions:
            methods.extend(
                sorted([
                    t[0] for t in inspect.getmembers(
                        mocked,
                        predicate=lambda x: inspect.isfunction(
                            x) or inspect.ismethod(x)) if t[0] != "__init__"
                ]))
    # we're mocking a module
    elif isinstance(mocked, types.ModuleType):
        name = name if name else mocked.__name__
        if mock_modules:
            modules.extend(
                sorted([
                    t[0] for t in inspect.getmembers(mocked, inspect.ismodule)
                ]))
        if mock_functions:
            functions.extend(
                sorted([
                    t[0] for t in inspect.getmembers(
                        mocked,
                        predicate=lambda x: inspect.isfunction(
                            x) or inspect.ismethod(x))
                ]))
        if mock_builtin:
            functions.extend(
                sorted([
                    t[0] for t in inspect.getmembers(mocked, inspect.isbuiltin)
                ]))

        if mock_classes:
            classes.extend(
                sorted([
                    t[0] for t in inspect.getmembers(mocked, inspect.isclass)
                    if t[1].__module__ == mocked.__name__
                ]))
        if mock_referenced_classes:
            classes.extend(
                sorted([
                    t[0] for t in inspect.getmembers(mocked, inspect.isclass)
                    if not t[1].__module__ == mocked.__name__
                ]))
    # mocking a function or a method
    elif inspect.isfunction(mocked) or inspect.ismethod(mocked):
        func_lister = FuncLister(mocked)
        func_lister.execute()
        if func_lister.warnings:
            func_lister.warnings.insert(0, "# warnings")
            func_lister.warnings[-1] = func_lister.warnings[-1] + "\n"

        return "\n".join(
            func_lister.warnings) + _pytest_mock_function_generate(
                func_lister.mocked_functions(), prepare_asserts_calls)
    # we're mocking a regular instance
    else:
        name = name if name else _guess_var_name(name)
        if mock_functions:
            methods.extend(
                sorted([
                    t[0] for t in inspect.getmembers(
                        mocked,
                        predicate=lambda x: inspect.isfunction(
                            x) or inspect.ismethod(x)) if t[0] != "__init__"
                ]))

    # todo: have a second function which returns the mocked objects
    #   this can help in testing and refactoring
    if MockingFramework.PYTEST_MOCK == framework:
        return _pytest_mock_generate(name, modules, functions, methods,
                                     classes, mock_classes_static,
                                     prepare_asserts_calls)
    else:
        raise ValueError(
            "Unsupported mocking framework: {0}. "
            "You are welcome to add code to support it :)".format(framework))


def safe_travels(action: str):
    """
    Takes care of calling `self.generic_visit(node)` and allows the inner
    method to focus on the logic. Including in the case of exception.

    If an exception does happen, a warning in the form of
    `f"# could not {action} on node: {str(node)}"` would be added to
    self.warnings, and the tree travel would continue to the next node.

    Args:
        action: the name of the action

    Returns:
        callable: the decorated method
    """
    def inner_decorator(method):
        @functools.wraps(method)
        def safe_visit(self, node, *args, **kwargs):
            try:
                method(self, node, *args, **kwargs)
            except Exception as e:
                node_repr = ast.dump(node)
                if sys.version_info >= (3, 8) and self.source_code:
                    node_repr = ast.get_source_segment(self.source_code, node)
                node_repr = "\n#  ".join(node_repr.split("\n"))
                warning = f"# could not {action} on node:\n" \
                          f"#  {node_repr}"
                logger.warning(warning, exc_info=True)
                self.warnings.append(warning)
            self.generic_visit(node)

        return safe_visit

    return inner_decorator


class FuncLister(ast.NodeVisitor):
    def __init__(self, mocked):
        self.mocked = mocked
        self.outer_module_name = inspect.getmodule(mocked).__name__
        self.source_code = textwrap.dedent(inspect.getsource(mocked))
        self.tree = ast.parse(self.source_code)

        self.warnings = []  # alert on all the unsupported syntax

        # these are the potential calls, some of them won't be mocked
        # every item is a tuple of two items: path to function, function name
        self.potential_calls = []

        # keys are names while values are true import paths
        # this is used to allow mocking dependencies that were renamed,
        # an example to such rename is an internal import in the UUT function
        self.import_mappings = {}

        # ignore all variable function calls:
        #   if they are parameters or assignments it's hard to know their type,
        #       so it's hard to mock the right thing
        #   if they were created by the result of calling a function that would
        #       be mocked - the user can change or assert for the return_value
        #       of that original mock
        self.ignored_variables = set()

    def execute(self):
        """
        Goes through the source code tree and collects any functions to mock.
        """
        super().visit(self.tree)

    def mocked_functions(self):
        """
        These are the functions which will be mocked.

        Returns:
            list of tuple:
            every item is a tuple of two items -
                path to function, function name.
                Like: ('tests.sample.code.tested_module.random', 'randint')
        """
        functions = OrderedDict()  # no need to mock same function called twice
        for id_and_func_path in self.potential_calls:
            skip_call = id_and_func_path[0] in self.ignored_variables
            id_and_func_path[0] = self.import_mappings.get(
                id_and_func_path[0],
                self.outer_module_name + '.' + id_and_func_path[0])
            replaced_path = ".".join(id_and_func_path)
            module_path, func_name = replaced_path.rsplit('.', 1)
            func_qualified_name = (
                module_path,
                func_name,
            )

            if not skip_call and func_qualified_name not in functions:
                functions[func_qualified_name] = None
        return functions.keys()

    @safe_travels("ignore function arguments")
    def visit_FunctionDef(self, node):
        for i, arg in enumerate(node.args.args + node.args.kwonlyargs +
                                [node.args.vararg, node.args.kwarg]):
            if arg:
                # support 'self', 'cls' by pointing it to the Class
                if 0 == i and inspect.ismethod(self.mocked):
                    self_var_name = arg.arg
                    class_name = self.mocked.__qualname__.split('.', 1)[0]
                    self.import_mappings[self_var_name] = \
                        self.outer_module_name + '.' + class_name
                else:
                    self.ignored_variables.add(arg.arg)

    @safe_travels("ignore variable assign")
    def visit_Assign(self, node):
        for target in node.targets:
            if not isinstance(target, ast.Subscript):
                target_assign = _stringify_node_path(target)
                self.ignored_variables.add(target_assign)

    @safe_travels("ignore variable annotated assign")
    def visit_AnnAssign(self, node):
        self.ignored_variables.add(node.target.id)

    @safe_travels("ignore with variables")
    def visit_withitem(self, node):
        if node.optional_vars:
            self.ignored_variables.add(node.optional_vars.id)

    @safe_travels("ignore comprehension variables")
    def visit_comprehension(self, node):
        inner_variables = node.target
        if not isinstance(inner_variables, ast.Tuple):
            inner_variables = ast.Tuple(elts=[node.target])

        for inner_variable in inner_variables.elts:
            target_assign = _stringify_node_path(inner_variable)
            self.ignored_variables.add(target_assign)

    @safe_travels("add internal import to known mappings")
    def visit_Import(self, node):
        for name in node.names:
            self.import_mappings[name.asname if name.asname else name.
                                 name] = name.name

    @safe_travels("add internal import from to known mappings")
    def visit_ImportFrom(self, node):
        for name in node.names:
            self.import_mappings[name.asname if name.asname else name.
                                 name] = node.module + "." + name.name

    @safe_travels("convert a function call into a mock")
    def visit_Call(self, node):
        id_and_func_path = _stringify_node_path(node.func).split('.', 1)
        self.potential_calls.append(id_and_func_path)


def _stringify_node_path(node):
    """
    Returns the qualified path the node is pointing to.

    Can return something like: var_name.attr.inner_attr.

    Args:
        node (ast.Name or ast.Attribute):

    Returns:
        str: the qualified path the node is pointing to.
    """
    if isinstance(node, ast.Name):
        stringify = node.id
    elif isinstance(node, ast.Attribute):
        stringify = _stringify_node_path(node.value) + "." + node.attr
    else:
        raise TypeError(f"Can't stringify node of type {type(node)}")
    return stringify


def _pytest_mock_function_generate(functions, prepare_asserts_calls):
    generated_code = ""
    unique_functions = set()
    mock_names = []
    if functions:
        generated_code += "# mocked functions\n"
        for (
                func_path,
                func_name,
        ) in functions:
            unique_name = get_unique_item(unique_functions, func_name)
            generated_mock_name, generated_mock_code = \
                _single_pytest_mock_module_entry_with_alias(unique_name,
                                                            func_name,
                                                            func_path)
            mock_names.append(generated_mock_name)
            generated_code += generated_mock_code

    if prepare_asserts_calls and mock_names:
        generated_code += "# calls to generate_asserts, " \
                          "put this after the 'act'\n" \
                          "import mock_autogen\n"
        for mock_name in mock_names:
            generated_code += _single_call_to_generate_asserts(mock_name)

    return generated_code


def _pytest_mock_generate(mocked_name, modules, functions, methods, classes,
                          mock_classes_static, prepare_asserts_calls):
    generated_code = ""
    mock_names = []
    if modules:
        generated_code += "# mocked modules\n"
        for module in modules:
            generated_mock_name, generated_mock_code = \
                _single_pytest_mock_module_entry(mocked_name, module)
            mock_names.append(generated_mock_name)
            generated_code += generated_mock_code
    if functions:
        generated_code += "# mocked functions\n"
        for func in functions:
            generated_mock_name, generated_mock_code = \
                _single_pytest_mock_module_entry(mocked_name, func)
            mock_names.append(generated_mock_name)
            generated_code += generated_mock_code
    if methods:
        generated_code += "# mocked methods\n"
        for func in methods:
            generated_code += _single_pytest_mock_object_entry(
                mocked_name, func)
    if classes:
        generated_code += "# mocked classes\n"
        for cls in classes:
            if mock_classes_static:
                generated_code += _mock_class_static(cls, mocked_name)
            else:
                generated_mock_name, generated_mock_code = \
                    _single_pytest_mock_entry_with_spec(
                        mocked_name,
                        cls,
                        mocked_name + "." + cls)
                mock_names.append(generated_mock_name)
                generated_code += generated_mock_code
    if prepare_asserts_calls and mock_names:
        generated_code += "# calls to generate_asserts, " \
                          "put this after the 'act'\n" \
                          "import mock_autogen\n"
        for mock_name in mock_names:
            generated_code += _single_call_to_generate_asserts(mock_name)

    return generated_code


def _single_pytest_mock_module_entry(mocked_name, entry):
    return "mock_{0}".format(entry), \
           ("mock_{0} = mocker.MagicMock(name='{0}')\n"
            "mocker.patch('{1}.{0}', new=mock_{0})\n"). \
               format(entry, mocked_name)


def _single_pytest_mock_module_entry_with_alias(mock_name, function, module):
    return f"mock_{mock_name}", \
           f"mock_{mock_name} = mocker.MagicMock(name='{mock_name}')\n" \
           f"mocker.patch('{module}.{function}', new=mock_{mock_name})\n"


def _single_pytest_mock_object_entry(mocked_name, entry):
    return "mocker.patch.object({0}, '{1}')\n".format(mocked_name, entry)


def _single_pytest_mock_entry_with_spec(mocked_name, entry, spec):
    return "mock_{0}".format(entry), \
           ("mock_{0} = mocker.MagicMock(name='{0}', spec={2})\n"
            "mocker.patch('{1}.{0}', new=mock_{0})\n"). \
               format(entry, mocked_name, spec)


def _mock_class_static(class_name, mocked_name):
    return ("""
class Mocked{0}Meta(type):
    static_instance = mocker.MagicMock(spec={1}.{0})

    def __getattr__(cls, key):
        return Mocked{0}Meta.static_instance.__getattr__(key)

class Mocked{0}(metaclass=Mocked{0}Meta):
    original_cls = {1}.{0}
    instances = []

    def __new__(cls, *args, **kwargs):
        Mocked{0}.instances.append(mocker.MagicMock(spec=Mocked{0}.original_cls))
        Mocked{0}.instances[-1].__class__ = Mocked{0}
        return Mocked{0}.instances[-1]

mocker.patch('{1}.{0}', new=Mocked{0})
""").format(class_name, mocked_name)


def _single_call_to_generate_asserts(mock_name):
    return "mock_autogen.generate_asserts(" \
           "{0}, name='{0}')\n".format(mock_name)


@copy_result_to_clipboard
@print_result
def generate_asserts(mock, name=''):
    """
    Generates the asserts matching to the call list of the sent mock.

    The generated asserts are printed to the console, copied to the clipboard
    and returned.

    Args:
        mock (Mock or MagicMock): the mock object to generate the asserts for
        name (string): the name of the mock parameter, if not provided would be
            guessed to match the argument name sent to the method and defaulted
            to 'arg'

    Returns:
        str: the asserts matching to the call list of the sent mock
    """
    name = name if name else _guess_var_name(mock)
    if not isinstance(mock, python_mock.MagicMock) and \
            not isinstance(mock, unittest.mock.MagicMock) and \
            not isinstance(mock, python_mock.Mock) and \
            not isinstance(mock, unittest.mock.Mock):
        raise TypeError("Unsupported mocking object: {0}. "
                        "You are welcome to add code to support it :)".format(
                            type(mock)))

    generated_asserts = ""
    if mock.call_args_list:
        generated_asserts += "assert {0} == {1}.call_count\n".format(
            len(mock.call_args_list), name)

    call_dictionary = OrderedDict()

    for all_calls in mock.mock_calls:
        method, args, kwargs = all_calls
        method = method.replace("()", ".return_value")
        if method and not method.startswith("."):
            method = "." + method
        if method not in call_dictionary:
            call_dictionary[method] = []
        call_dictionary[method].append(CallParameters(args, kwargs))

    had_multiple_calls_for_single_method = False
    for func_path, call_list in call_dictionary.items():
        if 1 == len(call_list):
            args, kwargs = call_list[0]
            generated_asserts += "{0}.assert_called_once_with({1})\n".format(
                name + func_path, _param_string(args, kwargs))
        else:
            had_multiple_calls_for_single_method = True
            generated_asserts += "{0}.assert_has_calls(calls=[".format(
                name + func_path)
            for call in call_list:
                args, kwargs = call
                generated_asserts += "call({0}),".format(
                    _param_string(args, kwargs))
            generated_asserts += "])\n"

    if had_multiple_calls_for_single_method:
        generated_asserts = "from mock import call\n\n" + generated_asserts

    if not generated_asserts:
        generated_asserts = "{0}.assert_not_called()".format(name)
    return generated_asserts


def _guess_var_name(var):
    """
    Guesses the argument name, according to the variable name sent to it, if
    unable to guess, returns 'arg'. See https://stackoverflow.com/a/2749881

    Args:
        var (object): the variable to figure the argument name

    Returns:
        str: the argument name, according to the variable name sent to it, if
            unable to guess, returns 'arg'.
    """
    for stack in range(2, len(inspect.stack())):
        lcls = inspect.stack()[stack][0].f_locals
        for name in lcls:
            if id(var) == id(lcls[name]):
                return name
    return 'arg'


def _param_string(args, kwargs):
    params = ""
    if args:
        params += ', '.join(['{!r}'.format(v) for v in args])
    if kwargs:
        if params:
            params += ', '
        params += ', '.join(
            ['{}={!r}'.format(k, v) for k, v in sorted(kwargs.items())])
    return re.sub(
        r'(?P<default_repr>\<.*? object at 0x[0-9A-Fa-f]+\>)',
        lambda default_repr: re.sub('[^0-9a-zA-Z.]+', '_', default_repr.group(
        )), params)
